# EAZY - Product Requirements Document (PRD)

## 1. Executive Summary

### 1.1 Problem Statement

현대 웹 애플리케이션은 복잡한 비즈니스 로직과 다양한 기술 스택으로 구성되어 있으며, 이에 따라 보안 취약점의 범위와 복잡도가 증가하고 있다.

**기업 규모와 관계없이, 보안 전문가 부족과 높은 비용으로 인해 적절한 보안 진단을 수행하기 어려운 상황이다.** 중소기업은 전담 보안 인력의 부족으로, 대기업은 진단 대상의 규모와 복잡성으로 어려움을 겪고 있다.

웹 애플리케이션 보안 진단은 전문 인력이 필요하고, 비용이 높으며, 시간이 오래 걸린다(평균 2주 이상). 기존의 자동화된 스캐너는 단순 패턴 매칭에 의존하여 비즈니스 로직 취약점을 놓치는 경우가 많고, 높은 오탐률로 인해 실무에서의 신뢰도가 낮다.

기존 도구들의 한계:
- **Burp Suite, OWASP ZAP** 등은 수동 작업 비중이 높아 전문가 의존도가 크다
- **Nuclei** 같은 자동화 도구는 패턴 기반으로 컨텍스트 이해가 부족하다
- **상용 AI 솔루션**은 높은 라이선스 비용과 낮은 접근성으로 중소기업에 비현실적이다
- **비즈니스 로직 취약점**은 기존 도구로 탐지하기 어렵다

### 1.2 Goal

EAZY는 AI 기반 블랙박스 모의해킹 도구로, 공격자 관점에서 웹 애플리케이션의 취약점을 자동으로 탐지하고 검증한다. 스마트 크롤링, AI 공격 시나리오 자동 생성, 오탐 필터링, 자동 리포팅을 통해 보안 진단의 속도와 정확도를 획기적으로 향상시키는 것을 목표로 한다.

EAZY는 **AI 기반 자동화**와 **블랙박스 접근법**을 결합하여, 전문 지식 없이도 고도화된 보안 진단을 수행할 수 있는 접근 가능한 솔루션을 제공한다.

### 1.3 Target Audience

| 사용자 그룹 | 우선순위 | 주요 니즈 | EAZY 제공 가치 |
|------------|----------|-----------|----------------|
| 보안 컨설팅 업체 | **Primary** | 다중 고객사 진단 효율화, 일관된 보고서 품질 | 자동화된 블랙박스 진단, 표준화된 리포트 생성 |
| 중/대기업 보안팀 | **Primary** | 대규모 자산 진단, 정기 점검 자동화 | 동시 다중 대상 진단, 감사 로그, 법적 준수 |
| DevSecOps 엔지니어 | Secondary | CI/CD 통합, 빠른 피드백 루프 | CLI 인터페이스, JSON 출력, 자동화 친화적 |
| 스타트업/중소기업 | Secondary | 저비용 진단 솔루션, 전문 인력 부재 | 무료/오픈소스, AI 기반 자동 분석, 직관적 사용성 |

---

## 2. Goals & Success Metrics

| 목표 (Goal) | 지표 (Metric) | 목표치 (Target) | 측정 시점 |
|---|---|---|---|
| 탐지 정확도 향상 | TPR (True Positive Rate / 진양성률) | > 85% | Phase 2 |
| 오탐 최소화 | FPR (False Positive Rate / 오탐률) | < 10% | Phase 2 |
| 미탐 최소화 | FNR (False Negative Rate / 미탐률) | < 15% | Phase 2 |
| 진단 속도 개선 | 평균 진단 소요 시간 | 100페이지 규모 사이트 기준 2시간 이내 (수동 대비 10배 이상) | Phase 1 |
| OWASP Top 10 커버리지 | 탐지 가능한 OWASP 카테고리 수 | 10 / 10 | Phase 3 |
| 리포트 품질 | PoC 재현 성공률 | > 90% | Phase 2 |

> **참고**: NPS (Net Promoter Score, 목표 > 50)는 Phase 3 (v1.0) 출시 이후부터 측정을 시작합니다.

### 2.1 측정 방법론 (Measurement Methodology)

**기준 테스트 환경:**

| 테스트 환경 | 용도 | 알려진 취약점 수 |
|---|---|---|
| OWASP Benchmark v1.2 | TPR/FPR/FNR 종합 측정 | 2,740개 테스트 케이스 |
| DVWA (Damn Vulnerable Web Application) | SQL Injection, XSS 등 기본 취약점 | 14개 카테고리 |
| OWASP Juice Shop | 현대적 웹앱 취약점 (SPA 기반) | 100+ 취약점 |
| WebGoat | 학습용 취약점 환경 | 30+ 레슨 |

**측정 공식:**
- TPR = TP / (TP + FN) — 실제 취약점 중 탐지한 비율
- FPR = FP / (FP + TN) — 정상을 취약점으로 잘못 탐지한 비율
- FNR = FN / (TP + FN) — 실제 취약점 중 놓친 비율

**측정 원칙:**
- 모든 측정은 CI 파이프라인(GitHub Actions)을 통해 자동화되고 재현 가능하도록 구성한다
- 속도 측정은 표준화된 100페이지 규모 테스트 사이트 기준으로 수행한다
- 릴리스마다 벤치마크를 실행하여 성능 회귀를 방지한다

---

## 3. Features & Requirements

### 3.1 Core Features

#### REQ-001: 정규식 기반 크롤링 엔진

**설명:** LLM API 호출 없이 정규식 패턴 매칭으로 웹 페이지의 구조를 파싱하는 경량 크롤링 엔진. AI API 비용 없이 빠르게 대상 웹사이트의 기본 구조를 파악한다.

**User Story:**
> 보안 담당자로서, AI API 비용 없이 빠르게 대상 웹사이트의 구조를 파악하고 엔드포인트를 수집할 수 있는 가벼운 크롤링을 원한다.

**Acceptance Criteria:**
- [x] 정규식으로 HTML에서 링크(`<a>`), 폼(`<form>`, `<input>`), 버튼(`<button>`), 스크립트 내 API 호출 패턴을 추출한다
- [x] 크롤링 결과를 구조화된 사이트맵으로 저장한다
- [x] 크롤링 깊이 및 범위를 사용자가 설정할 수 있다
- [x] robots.txt 준수 옵션을 제공한다
- [x] LLM API 없이 오프라인 환경에서도 동작한다
- [x] URL, 파라미터, 엔드포인트 목록을 JSON 형태로 출력한다
- [x] URL 패턴 정규화로 동일 구조 페이지를 자동 그룹핑하여 중복 크롤링을 방지한다

**URL 패턴 정규화 (URL Pattern Normalization):**

동일 구조의 URL(예: `/challenges/2692`, `/challenges/2691`)을 패턴(`/challenges/<int>`)으로 그룹핑하여, 크롤링 예산을 다양한 경로 탐색에 효율적으로 배분한다.

세그먼트 타입 감지 (구체적 → 일반적 순서):

| 타입 | 패턴 | 예시 |
|------|------|------|
| `<uuid>` | UUID v4 형식 | `/items/550e8400-e29b-41d4-a716-446655440000` |
| `<int>` | 순수 숫자 | `/posts/123`, `/page/2` |
| `<date>` | YYYY-MM-DD | `/archive/2025-01-15` |
| `<hash>` | 고정길이 hex (32/40/64자) | `/commit/a1b2c3d4e5f6...` |
| `<slug>` | 소문자 + 하이픈 | `/blog/my-first-post` |
| `<string>` | 그 외 전부 (catch-all) | `/users/abc123` |

그룹핑 규칙:
- 같은 경로 위치의 세그먼트들이 전부 동일 타입이면 해당 타입 유지
- 하나라도 다른 타입이 섞이면 `<string>`으로 승격
- 같은 패턴의 URL은 N개(기본 3개)만 샘플링, 나머지는 스킵
- 결과에 "이 패턴으로 M개 URL 발견, N개 샘플링" 정보 포함

---

#### REQ-002A: 스마트 크롤링 엔진 (코어)

**설명:** Playwright 기반 헤드리스 브라우저로 실제 사용자처럼 웹사이트를 탐색하여 페이지 구조, 폼, API 엔드포인트를 자동으로 식별한다.

**User Story:**
> 보안 담당자로서, 대상 웹 애플리케이션의 URL만 입력하면 자동으로 모든 페이지와 엔드포인트가 매핑되어 진단 범위가 누락 없이 설정되기를 원한다.

**Acceptance Criteria:**
- [x] Playwright 기반 헤드리스 브라우저로 실제 사용자와 동일하게 페이지를 탐색한다
- [x] JavaScript 렌더링이 필요한 SPA(Single Page Application)를 지원한다
- [x] 폼 필드, 버튼, 링크, API 호출을 자동으로 식별한다
- [x] 크롤링 결과를 지식 그래프 형태로 구조화한다
- [x] 크롤링 깊이 및 범위를 사용자가 설정할 수 있다
- [x] robots.txt 및 크롤링 제한 정책을 준수할 수 있는 옵션을 제공한다

---

#### REQ-002B: LLM Provider 추상화 및 인증

**설명:** 다양한 LLM Provider를 통합하는 추상화 레이어를 구축한다. 구독 기반 인증(OAuth)과 API 키 방식을 모두 지원하며, 벤더에 종속되지 않는 범용 인터페이스로 설계한다. REQ-002C, REQ-002D 및 향후 모든 LLM 관련 기능의 기반 인프라이다.

**User Story:**
> 보안 담당자로서, 별도 API 과금 없이 기존 Gemini 구독만으로 AI 기능을 사용하고 싶다. 또한 향후 다른 LLM(Codex, Claude Code 등)으로도 쉽게 전환할 수 있기를 원한다.

**Acceptance Criteria:**
- [ ] LLMProvider 추상 인터페이스를 정의한다 (벤더 무관한 범용 계약: send prompt → receive structured response)
- [ ] **Gemini OAuth Provider**: Google 로그인(OAuth 2.0) 기반 인증. Gemini CLI의 OAuth 플로우를 미러링하여 `cloudaicompanion.googleapis.com` 엔드포인트를 사용한다. Gemini 구독 한도 내에서 별도 API 과금 없이 동작한다
- [ ] **Antigravity OAuth Provider**: Google Antigravity IDE의 OAuth 인증. Antigravity rate limit을 사용하여 프리미엄 모델에 접근한다
- [ ] **Gemini API Provider**: API 키 기반 인증. Google AI Studio 무료 티어(분당 15 요청, 일당 1,500 요청) 또는 유료 요금제를 지원한다
- [ ] OAuth 인증 시 브라우저 기반 consent 플로우 → 로컬 콜백 서버 → refresh token 저장/자동 갱신을 지원한다
- [ ] Rate limit 도달 시 멀티 계정 자동 전환을 지원한다 (계정별 상태 추적 + 자동 로테이션)

**LLM Provider 아키텍처:**

```
LLMProvider (추상 인터페이스)
│   supports_oauth: bool          — OAuth 인증 가능 여부
│   supports_multi_account: bool  — 멀티 계정 전환 가능 여부
│   billing_type: str             — "subscription" | "per_token" | "free"
│
│  [Phase 2 — v0.5]
├── GeminiOAuthProvider       — Google 로그인 (구독, 멀티 계정 ✅)
├── AntigravityOAuthProvider  — Antigravity (구독, 멀티 계정 ✅)
├── GeminiAPIProvider         — API 키 (무료 티어 / 유료, 멀티 키 ✅)
│
│  [Future — v2.0+]
├── CodexOAuthProvider        — OpenAI Codex OAuth (구독, 멀티 계정 ✅)
├── ClaudeAPIProvider         — Anthropic API 키 전용 (멀티 키 ✅)
└── OllamaProvider            — 로컬 모델 (완전 오프라인, 무료)
```

**Provider별 Capability 매트릭스:**

| Provider | OAuth | 멀티 계정 | 과금 방식 | 비고 |
|----------|:-----:|:---------:|-----------|------|
| GeminiOAuth | ✅ | ✅ | subscription | Gemini CLI OAuth 미러링 |
| Antigravity | ✅ | ✅ | subscription | Antigravity IDE 엔드포인트 |
| GeminiAPI | ❌ | ✅ (멀티 키) | per_token / free_tier | AI Studio API 키 |
| CodexOAuth | ✅ | ✅ | subscription | ChatGPT Plus/Pro OAuth |
| ClaudeAPI | ❌ | ✅ (멀티 키) | per_token | Anthropic이 서드파티 OAuth 차단 (2026.01) |
| Ollama | ❌ | ❌ | free | 로컬 GPU 필요 |

> **확장성 설계 원칙**: LLMProvider 인터페이스는 특정 벤더에 종속되지 않는 범용 계약(`send prompt → receive structured response`)으로 정의한다. 각 Provider는 인증 방식(OAuth, API 키, 로컬)과 호출 엔드포인트만 다르며, 크롤링/스캐닝 로직은 Provider에 무관하게 동일하게 동작한다. Provider마다 capability가 다르므로(`supports_oauth`, `supports_multi_account`, `billing_type`), 인터페이스에 capability flag를 포함하여 런타임에 적절한 동작을 선택한다.

> **참고**: OAuth Provider(Gemini, Antigravity, Codex)는 각 서비스의 비공식 내부 엔드포인트를 사용하며, 서비스 제공자가 엔드포인트를 변경하면 영향받을 수 있다. Anthropic은 2026년 1월 서드파티 OAuth 접근을 차단하여 Claude는 API 키 방식만 가능하다. Provider 추상화로 이러한 변경에 빠르게 대응할 수 있도록 설계한다.

---

#### REQ-002C: LLM 기반 크롤링 강화

**설명:** REQ-002B의 LLM Provider를 활용하여 크롤링 정확도를 향상시킨다. 페이지 컨텍스트 분석으로 숨겨진 엔드포인트를 추론하고, 지능형 폼 채우기, 기능 흐름도 자동 생성을 수행한다.

**User Story:**
> 보안 담당자로서, AI가 페이지 컨텍스트를 이해하여 일반 크롤러가 놓치는 숨겨진 기능과 엔드포인트까지 탐지해 주기를 원한다.

**Acceptance Criteria:**
- [ ] LLM Provider를 통해 페이지 컨텍스트를 이해하고 숨겨진 엔드포인트/기능을 추론한다
- [ ] LLM 기반 크롤링 우선순위를 자동으로 결정한다
- [ ] REQ-001(정규식 크롤링)과 독립적으로 LLM 기반 파싱을 수행한 후, 정규식 크롤링에서 발견하지 못한 부분을 보완 반영한다
- [ ] LLM 기반 지능형 폼 필드 자동 채우기를 지원한다
- [ ] 크롤링 결과에서 API 간 호출 관계와 기본 기능 흐름도를 자동 생성한다

---

#### REQ-002D: LLM 호출 최적화 파이프라인

**설명:** LLM 호출 횟수와 토큰 사용량을 최소화하는 4단계 최적화 파이프라인을 구축한다. OAuth 구독 기반에서는 rate limit 관리, API 키 기반에서는 비용 절감이 주 목적이다.

**User Story:**
> 보안 담당자로서, 대규모 사이트 진단 시에도 LLM rate limit에 걸리지 않고, 빠르고 효율적으로 AI 분석이 수행되기를 원한다.

**Acceptance Criteria:**
- [ ] **L1 — HTML 전처리**: style/script 본문, 주석을 제거하고 DOM 구조만 추출하여 입력 토큰을 90% 절감한다
- [ ] **L2 — 선택적 LLM 호출**: 폼, 동적 콘텐츠, 인증 관련 등 "흥미로운" 페이지만 LLM을 호출하고, 정적 페이지(about, contact 등)는 스킵한다
- [ ] **L3 — URL 패턴 캐싱**: 기존 URLPatternNormalizer와 연동하여 동일 패턴 URL 중 대표 1개만 LLM 분석 후, 결과를 패턴 그룹 전체에 적용한다
- [ ] **L4 — 배치 + 프롬프트 최적화**: 여러 페이지를 1회 호출로 묶고, structured JSON output으로 응답 토큰을 최소화한다
- [ ] `--llm-calls-budget N` 옵션으로 최대 LLM 호출 횟수를 제한할 수 있다

**4단계 최적화 효과 (100페이지 사이트 기준):**

| 단계 | 전략 | 절감률 | 잔여 LLM 호출 |
|------|------|--------|---------------|
| 원본 | — | — | 100회 |
| L1 HTML 전처리 | 입력 토큰 90% 감소 | 입력 크기 절감 | 100회 |
| L2 선택적 호출 | 정적 페이지 스킵 | 호출 60% 감소 | 40회 |
| L3 패턴 캐싱 | 동일 패턴 1회만 | 호출 50% 감소 | 20회 |
| L4 배치 처리 | 5페이지/1회 묶음 | 호출 80% 감소 | **4회** |

---

#### REQ-003: AI 기반 공격 시나리오 자동 생성

**설명:** 크롤링 결과를 기반으로 각 URL/엔드포인트에 대한 공격 시나리오를 Gemini API를 활용하여 자동 생성한다.

**User Story:**
> 보안 담당자로서, 크롤링된 각 페이지에 대해 AI가 맞춤형 공격 시나리오를 자동 생성해 주어, 수동으로 시나리오를 작성하는 시간을 절약하고 싶다.

**Acceptance Criteria:**
- [ ] OWASP Top 10 전 항목에 대한 공격 시나리오를 생성한다 (Injection, XSS, SSRF, IDOR, CSRF 등)
- [ ] 비즈니스 로직 취약점 시나리오를 생성한다 (권한 우회, 가격 조작, Race Condition 등)
- [ ] 페이지 컨텍스트를 이해하여 맞춤형 공격 페이로드를 생성한다
- [ ] URL당 최소 30개 이상의 공격 시나리오를 생성한다
- [ ] 시나리오에 공격 유형, 대상, 예상 결과, 심각도가 포함된다
- [ ] REQ-002A/B에서 생성된 기능 흐름도를 기반으로 비즈니스 로직 취약점 공격 시나리오를 도출한다
- [ ] 기능 흐름의 각 단계에서 권한 우회, 순서 조작, 상태 변조 등 로직 취약점 가능성을 분석한다
- [ ] 예: 회원가입 → 로그인 → 권한 확인 → 데이터 접근 흐름에서 권한 우회 시나리오를 자동 생성한다

> **※ URL당 30개 기준 근거:** OWASP Top 10 카테고리(10개) × 카테고리당 평균 3개 변형 페이로드 = 최소 30개. 실제 URL의 파라미터 수와 컨텍스트에 따라 동적으로 조정된다. 예: 파라미터 2개 URL → 기본 30개, 파라미터 5개 URL → 50개 이상 생성 가능.

---

#### REQ-004: 자동 취약점 진단 실행

**설명:** 생성된 공격 시나리오를 자동으로 실행하여 취약점을 탐지한다.

**User Story:**
> 보안 담당자로서, 생성된 시나리오가 자동으로 실행되어 실제로 악용 가능한 취약점만 식별되기를 원한다.

**Acceptance Criteria:**
- [ ] 생성된 모든 공격 시나리오를 자동으로 실행한다
- [ ] 다단계 공격 흐름을 재현한다 (예: 로그인 → 권한 상승 → 데이터 접근)
- [ ] 프로덕션 환경에 미치는 영향을 최소화하는 안전한 페이로드를 사용한다 (아래 가이드라인 참조)
- [ ] 병렬 실행으로 진단 속도를 최적화한다
- [ ] 진단 진행 상황을 실시간으로 표시한다

**안전한 페이로드 가이드라인:**

| 취약점 유형 | 허용 페이로드 | 금지 페이로드 |
|---|---|---|
| **SQL Injection** | SELECT 기반 조회, Time-based blind (최대 5초 지연) | INSERT/UPDATE/DELETE, DROP TABLE, 데이터 변조 |
| **XSS** | alert()/console.log() 기반 실행 확인 | 쿠키 탈취, 세션 하이재킹, 외부 서버 콜백 |
| **SSRF** | 내부 메타데이터 조회 (169.254.169.254) | 내부 서비스 공격, 파일 시스템 접근 |
| **File Upload** | 무해한 텍스트 파일 업로드 | 웹쉘, 실행 파일 업로드 |
| **Command Injection** | whoami, id, hostname 등 읽기 전용 | rm, shutdown, 파일 삭제/수정 명령 |
| **IDOR** | 다른 사용자 데이터 조회 시도 | 다른 사용자 데이터 수정/삭제 |

**추가 규칙:**
- 모든 페이로드는 대상 시스템의 데이터 무결성을 보존해야 한다
- Time-based 공격은 최대 5초 지연으로 제한한다
- 파일 시스템 쓰기 작업은 금지한다
- 페이로드 실행 전 사용자 확인 옵션 제공 (`--confirm` 플래그)
- QA/스테이징 환경으로 명시적으로 태깅된 대상에 대해서는 제한을 완화할 수 있다

---

#### REQ-005A: AI 기반 오탐 필터링 및 검증

**설명:** AI 기반으로 탐지된 취약점의 실제 악용 가능성을 검증하고, 오탐을 자동으로 분류한다.

**User Story:**
> 보안 담당자로서, 진단 결과에서 오탐이 자동으로 걸러져 실제 위험한 취약점에만 집중할 수 있기를 원한다.

**Acceptance Criteria:**
- [ ] AI 기반 오탐/진양성 자동 분류 기능을 제공한다
- [ ] 탐지된 취약점의 실제 악용 가능성을 검증한다
- [ ] 재현 가능한 PoC(Proof of Concept) 코드를 자동 생성한다
- [ ] 오탐률 10% 미만을 유지한다
- [ ] 검증 결과에 대한 신뢰도 점수를 제공한다

---

#### REQ-005B: RAG 기반 취약점 지식 관리 시스템

**설명:** 확인된 취약점을 일반화하여 벡터 DB에 저장하고, 이를 재활용하여 향후 진단 정확도를 지속적으로 개선한다.

**User Story:**
> 보안 담당자로서, 이전 진단에서 확인된 취약점 지식이 축적되어 새로운 진단의 정확도가 점점 향상되기를 원한다.

**Acceptance Criteria:**
- [ ] 사용자가 진양성으로 확인한 취약점을 LLM 기반 일반화 엔진을 통해 사이트 독립적 지식으로 변환한다
- [ ] 일반화된 취약점 지식(취약점 원인, 공격 페이로드 템플릿, 공격 원리, CWE/OWASP 매핑)을 RAG(벡터 DB)에 저장한다
- [ ] 저장 시 사이트 특정 정보(도메인, URL, 세션값 등)를 자동 제거하여 여러 사이트에서 범용적으로 활용 가능하게 한다
- [ ] 새로운 진단 시 RAG에서 유사 취약점 지식을 검색하여 오탐/진탐 판별 정확도를 보강한다
- [ ] 기존 지식과 유사도가 높은 새 취약점은 기존 지식에 병합하고 신뢰도 점수를 갱신한다
- [ ] 축적된 지식의 진부화를 방지하기 위해 시간 기반 신뢰도 감쇠 및 실패 피드백 반영 메커니즘을 제공한다
- [ ] Cold Start 대응: 초기 지식 베이스로 공개 취약점 DB(CVE, CWE)와 OWASP 테스트 가이드를 사전 임베딩하여 제공한다

---

#### REQ-006: 리포트 생성

**설명:** 취약점별 상세 리포트를 자동 생성하며, 대시보드를 통한 전체 현황 시각화를 제공한다.

**User Story:**
> 보안 담당자로서, 진단 완료 후 경영진에게 보고할 수 있는 수준의 상세한 리포트가 자동으로 생성되기를 원한다.

**Acceptance Criteria:**
- [ ] 취약점별 상세 정보를 포함한다 (설명, 심각도, 영향 범위, PoC, 대응 방안)
- [ ] CVSS 점수를 자동 산출한다
- [ ] 대시보드에서 전체 진단 현황을 시각화한다
- [ ] PDF/HTML 형식으로 리포트를 내보낼 수 있다
- [ ] 취약점 심각도별 통계 및 트렌드를 제공한다

---

#### REQ-007: 인증 및 세션 관리

**설명:** 다양한 인증 방식을 지원하여 로그인이 필요한 페이지도 진단할 수 있도록 한다.

**User Story:**
> 보안 담당자로서, 로그인이 필요한 내부 시스템도 진단할 수 있도록 다양한 인증 방식이 지원되기를 원한다.

**Acceptance Criteria:**
- [ ] ID/Password 기반 인증을 지원한다
- [ ] OAuth 2.0 인증 흐름을 지원한다
- [ ] JWT 토큰 기반 인증을 지원한다
- [ ] 세션 쿠키 기반 인증을 지원한다
- [ ] 프록시 연동을 통한 내부 시스템 접근을 지원한다
- [ ] 인증 정보의 안전한 저장 및 관리를 제공한다
- [ ] MFA(다중 인증) 환경을 지원한다 (TOTP, SMS 코드 입력 프롬프트 제공)
- [ ] API Key 기반 인증을 지원한다 (HTTP Header 또는 Query 파라미터 방식)

---

#### REQ-008: 법적/윤리적 준수

**설명:** 모의해킹 도구의 법적 책임과 윤리적 사용을 보장하기 위한 요구사항.

**User Story:**
> 보안 담당자로서, 합법적이고 윤리적인 범위 내에서만 진단이 수행되도록 보장받고 싶다.

**Acceptance Criteria:**

**AC-008.1: 사용자 동의 및 인가 확인**
- [ ] 진단 시작 전 명시적인 사용자 동의 획득 프로세스 구현
- [ ] 대상 도메인/IP에 대한 소유권 또는 진단 권한 확인 메커니즘
- [ ] 동의 확인서 템플릿 제공 (조직 내 승인 프로세스용)

**AC-008.2: 감사 로그 (Audit Log) 자동 기록**
- [ ] 타임스탬프 (ISO 8601, UTC 기준), 대상 정보, 수행 작업, 결과, 사용자 정보, 설정 정보를 기록한다
- [ ] 로그 파일 변조 방지 (append-only mode)
- [ ] 로그 무결성 검증 (해시 체인 또는 서명)

**AC-008.3: 권한 없는 대상 스캔 방지**
- [ ] 진단 허용 도메인/IP 목록 사전 등록 (화이트리스트)
- [ ] 화이트리스트 외 대상 스캔 시도 시 자동 차단
- [ ] 와일드카드 지원: `*.example.com`, `192.168.1.0/24`
- [ ] 크롤링 중 외부 도메인 자동 차단 (리다이렉트 방지)

**AC-008.4: 법적 면책 조항 및 책임 경고**
- [ ] 최초 실행 시 (또는 새 버전 업데이트 시) 법적 고지 의무 표시
- [ ] 관련 법률 안내: 정보통신망법, 개인정보보호법, 형법 제314조
- [ ] 동의 선택 전까지 프로그램 진행 불가, 거부 시 즉시 종료

**AC-008.5: 진단 대상 범위 (Scope) 사전 정의**
- [ ] 포함/제외 경로, 허용 HTTP 메서드, 진단 심도 설정 지원
- [ ] Scope 외부 URL 발견 시 크롤링 자동 스킵
- [ ] 민감 작업 (삭제, 결제 등) 자동 감지 및 차단

**AC-008.6: 감사 로그 보관 및 무결성 보장**
- [ ] 최소 보관 기간: 1년
- [ ] 해시 체인: 각 로그 엔트리에 이전 엔트리 해시 포함
- [ ] `eazy audit-verify` 명령어로 로그 변조 검증 기능 제공

---

#### REQ-009: CLI 인터페이스

**설명:** 사용자가 명령줄을 통해 진단을 설정, 실행, 모니터링할 수 있는 CLI 인터페이스.

**User Story:**
> 보안 담당자로서, 터미널에서 직관적인 명령어로 진단을 실행하고 결과를 확인할 수 있기를 원한다.

**Acceptance Criteria:**
- [ ] `eazy scan <url>` 명령으로 기본 진단을 실행할 수 있다
- [ ] `eazy crawl <url>` 명령으로 크롤링만 별도 실행할 수 있다
- [ ] `--depth`, `--scope`, `--auth` 등 주요 옵션을 제공한다
- [ ] 진단 진행률을 실시간 프로그레스 바로 표시한다
- [ ] 결과를 JSON/텍스트/테이블 형식으로 출력할 수 있다
- [ ] `--output` 옵션으로 결과 파일 경로를 지정할 수 있다
- [ ] `eazy resume <scan-id>` 명령으로 중단된 스캔을 재개할 수 있다
- [ ] `--help` 명령으로 모든 옵션에 대한 도움말을 제공한다

---

#### REQ-010: 패턴 기반 취약점 스캐닝

**설명:** LLM 없이 알려진 취약점 패턴과 시그니처를 기반으로 기본적인 취약점을 탐지하는 스캐너.

**User Story:**
> 보안 담당자로서, AI API 없이도 주요 웹 취약점(XSS, SQLi 등)을 빠르게 탐지할 수 있는 기본 스캐닝을 원한다.

**Acceptance Criteria:**
- [ ] SQL Injection 기본 패턴 탐지 (에러 기반, Boolean 기반)
- [ ] Reflected XSS 기본 패턴 탐지
- [ ] 디렉토리 트래버설 탐지
- [ ] 민감 정보 노출 탐지 (서버 헤더, 에러 메시지)
- [ ] 기본 CSRF 토큰 부재 탐지
- [ ] 보안 헤더 누락 탐지 (CSP, HSTS, X-Frame-Options 등)
- [ ] 알려진 CVE 시그니처 기반 탐지 (버전 핑거프린팅)
- [ ] 스캔 결과를 구조화된 JSON으로 출력한다

---

#### REQ-011: 동시 다중 대상 진단

**설명:** 복수의 대상 웹사이트를 동시에 병렬로 진단할 수 있는 기능.

**User Story:**
> 보안 컨설팅 업체로서, 여러 고객의 웹사이트를 동시에 진단하여 업무 효율성을 극대화하고 싶다.

**Acceptance Criteria:**
- [ ] 최대 동시 진단 대상 수를 설정할 수 있다 (기본값: 3, 최대: 10)
- [ ] 대상별 리소스(CPU, 메모리, 네트워크) 사용량을 제한할 수 있다
- [ ] 대상별 독립적인 진행 상황 모니터링을 제공한다
- [ ] 개별 대상의 진단을 독립적으로 중단/재개할 수 있다
- [ ] 대상 간 인증 정보 및 세션이 격리된다
- [ ] 전체 진단 완료 후 통합 리포트를 생성할 수 있다

---

### 3.2 Out-of-Scope (v1.0)

| 항목 | 사유 |
|------|------|
| 모바일 앱(iOS/Android) 네이티브 취약점 진단 | 웹 애플리케이션에 집중, 모바일은 별도 도구 필요 |
| API 전용 서버(UI 없음) 진단 | v2.0에서 지원 예정 |
| 네트워크 레벨 취약점 (포트 스캐닝, 서비스 핑거프린팅) | 블랙박스 웹 진단 범위 외 |
| 소스코드 정적 분석 (SAST) | 블랙박스 방식만 지원 |
| DDoS / 부하 테스트 | 보안 진단 목적에 벗어남 |
| IoT 디바이스 보안 진단 | 웹 애플리케이션 전용 도구 |
| 실시간 모니터링 / WAF 기능 | 진단 도구와 방어 도구의 역할 분리 |

---

### 3.3 비기능 요구사항 (Non-Functional Requirements)

#### 3.3.1 성능 (Performance)

**크롤링 처리량:**
- 정규식 기반 크롤링: 시간당 최소 1,000개 페이지 처리
- 스마트 크롤링 (AI 기반): 시간당 최소 200개 페이지 처리
- 혼합 모드: 정규식 우선 처리 후 AI 보완, 시간당 600~800개 페이지

**스캔 속도:**
- 소규모 사이트 (10~50 페이지): 30분 이내 완전 진단
- 중규모 사이트 (50~100 페이지): 2시간 이내 완전 진단
- 대규모 사이트 (100~500 페이지): 8시간 이내 완전 진단
- 초대규모 사이트 (500+ 페이지): 점진적 결과 제공, 24시간 이내 1차 진단 완료

**동시 실행:**
- 최소 동시 요청: 10개 병렬 HTTP 요청 처리
- 최대 병렬 시나리오: 50개 취약점 검증 시나리오 동시 실행
- 동적 조절: 타겟 서버 부하 감지 시 자동 속도 조절 (Rate Limiting)

**API 응답 지연:**
- Gemini API 호출 포함: 시나리오당 평균 5초 이내
- 캐싱 적용 시: 중복 분석 요청 1초 이내 응답
- 타임아웃 정책: API 호출 최대 30초, 초과 시 폴백 메커니즘 작동

#### 3.3.2 보안 (Security)

**인증 정보 보호:**
- AES-256-GCM 방식으로 모든 크리덴셜 암호화
- OS 키체인 활용 (macOS Keychain, Windows Credential Manager, Linux Secret Service)
- 민감 정보 사용 후 즉시 메모리 제로화 (secure erase)

**데이터 암호화:**
- 전송 중 암호화 (in transit): TLS 1.3 이상 강제
- 저장 시 암호화 (at rest): 진단 결과, 세션 데이터, 로그 파일 전체 암호화

**민감 정보 처리:**
- 리포트 및 로그에서 패스워드, API 키, 토큰 자동 마스킹
- API 키는 코드베이스 외부 환경 변수 또는 볼트에 저장
- API 키 사용 이력 전체 로깅

#### 3.3.3 가용성 (Availability)

**장애 복구:**
- 체크포인트 시스템: 10분마다 또는 100개 페이지마다 진행 상태 자동 저장
- 중단 재개: 중단 시점부터 재시작 가능 (`eazy resume <scan-id>`)
- 재시작 시 이미 처리된 항목 자동 스킵

**네트워크 안정성:**
- 일시적 네트워크 장애 시 최대 3회 재시도 (Exponential Backoff: 1초 → 2초 → 4초)
- 타임아웃 계층화: 연결 타임아웃 10초, 읽기 타임아웃 30초, 전체 타임아웃 60초

**Graceful Degradation:**
- Gemini API 장애 시 패턴 기반 스캐닝으로 자동 폴백
- 일부 스캔 실패 시에도 완료된 부분 결과 리포트 생성
- 장애 상황 및 폴백 모드 실시간 사용자 안내

#### 3.3.4 확장성 (Scalability)

**대규모 사이트 처리:**
- 10,000개 이상 페이지 사이트 처리 가능
- 워커 프로세스 기반 병렬 처리 아키텍처

**메모리 관리:**
- 페이지 수에 비례한 선형 증가, 최대 8GB 이내 제한
- 초과 시 디스크 스왑 또는 배치 처리

**데이터 저장:**
- 최소 1년간 스캔 결과 이력 보관 (최소 1,000건)
- 90일 이상 경과 결과 자동 아카이브

#### 3.3.5 호환성 (Compatibility)

**운영 체제:**
- macOS 13 (Ventura) 이상
- Ubuntu 22.04 LTS 이상
- Windows 10 (21H2) 이상

**런타임 환경:**
- Python: 3.12+
- Node.js: 20 LTS+

**하드웨어:**
- 최소 사양: 4코어 CPU, 8GB RAM, 20GB 여유 디스크
- 권장 사양: 8코어 CPU, 16GB RAM, 100GB SSD
- CPU 아키텍처: x86_64 (Intel/AMD), ARM64 (Apple Silicon)

**네트워크:**
- HTTP/1.1, HTTP/2 지원
- HTTP/HTTPS 프록시, SOCKS5 지원
- IPv6 환경 완전 지원

---

## 4. Technical Constraints & System Context

### 4.1 Technology Stack

| Component | Technology | 선정 사유 |
|-----------|-----------|-----------|
| **Language** | Python 3.12+ | 풍부한 보안 라이브러리 생태계, AI/ML 통합 용이 |
| **CLI Framework** | Click / Typer | 직관적인 CLI 구축, 자동 도움말 생성, 타입 힌트 지원 |
| **Backend Framework** | FastAPI | 비동기 처리 성능, 자동 API 문서화, 타입 안전성 |
| **Async Task Processing** | Celery + Redis | 안정적인 분산 작업 큐, 모니터링 도구 풍부, 확장성 우수 |
| **Frontend** | React + Next.js | 대시보드 구현에 적합, 모던 웹 개발 생태계 |
| **Database** | PostgreSQL 15+ | JSONB 지원, 감사 로그 저장, 트랜잭션 무결성 |
| **Crawling Engine** | Playwright | 헤드리스 브라우저 기반 스마트 크롤링 |
| **AI/LLM** | Gemini API | 공격 시나리오 생성, 오탐 분류, 컨텍스트 분석 |
| **LLM Abstraction** | LiteLLM / LangChain | 다중 LLM 제공자 통합, Fallback 메커니즘 구현 용이 |
| **Vector DB (RAG)** | Qdrant | 고성능 유사도 검색, 메타데이터 필터링 지원, 프로덕션 안정성 |
| **Report Export** | WeasyPrint / Jinja2 | PDF/HTML 리포트 생성 |

### 4.2 Development Environment

| 항목 | 사양 |
|------|------|
| Python | 3.12+ |
| Node.js | 20 LTS |
| Package Manager | uv (Python), pnpm (Node.js) |
| 테스트 프레임워크 | pytest (Backend), Vitest (Frontend) |
| CI/CD | GitHub Actions |
| 코드 품질 | Ruff (linter/formatter), ESLint, Prettier |

### 4.3 Architecture Overview

```
┌─────────────────────────────────────────────────────┐
│                    EAZY CLI                          │
│               (Click/Typer 기반)                     │
└──────────────────┬──────────────────────────────────┘
                   │ (직접 모듈 호출)
┌──────────────────▼──────────────────────────────────┐
│               FastAPI Backend                        │
│  ┌──────────────────────────────────────────────┐   │
│  │         비동기 태스크 처리 레이어              │   │
│  │         (Celery + Redis)                      │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────────┐  │   │
│  │  │ Crawl    │ │ Scan     │ │ Report       │  │   │
│  │  │ Worker   │ │ Worker   │ │ Worker       │  │   │
│  │  └──────────┘ └──────────┘ └──────────────┘  │   │
│  └──────────────────────────────────────────────┘   │
│                                                      │
│  ┌──────────┐ ┌──────────┐ ┌──────────────────┐    │
│  │ Crawler  │ │ Scanner  │ │ Report Generator │    │
│  │ Engine   │ │ Engine   │ │                  │    │
│  └────┬─────┘ └────┬─────┘ └────────┬─────────┘    │
│       │            │                │               │
│  ┌────▼────────────▼────────────────▼─────────┐    │
│  │           Gemini AI Engine                  │    │
│  │  (Scenario Gen / FP Filter / PoC Gen)      │    │
│  │  + LLM Abstraction Layer (Fallback 지원)    │    │
│  └────────────────────────────────────────────┘    │
│                                                      │
│  ┌────────────────────┐ ┌────────────────────────┐  │
│  │   PostgreSQL       │ │  Qdrant (Vector DB)    │  │
│  │   (Scan Results /  │ │  (RAG Knowledge Base / │  │
│  │    Reports /       │ │   Vuln Patterns /      │  │
│  │    Audit Logs)     │ │   Payloads)            │  │
│  └────────────────────┘ └────────────────────────┘  │
│                                                      │
│  ┌────────────────────────────────────────────────┐ │
│  │              REST API Layer                     │ │
│  │         (Dashboard 통신용)                      │ │
│  └──────────────────┬─────────────────────────────┘ │
└─────────────────────┼───────────────────────────────┘
                      │ (REST API)
┌─────────────────────▼───────────────────────────────┐
│           Local Web Dashboard                        │
│          (React + Next.js)                           │
│  ┌──────────┐ ┌──────────┐ ┌────────────────┐      │
│  │ Scan     │ │ Report   │ │ Vulnerability  │      │
│  │ Manager  │ │ Viewer   │ │ Dashboard      │      │
│  └──────────┘ └──────────┘ └────────────────┘      │
└──────────────────────────────────────────────────────┘
```

**주요 컴포넌트 설명:**

| 컴포넌트 | 설명 |
|---------|------|
| **EAZY CLI** | Click/Typer 기반 CLI. Backend 모듈을 직접 호출하여 동일 프로세스 내에서 실행 |
| **비동기 태스크 처리 (Celery + Redis)** | 크롤링, 스캐닝, 리포트 생성 등 장시간 작업을 백그라운드 워커로 병렬 처리 |
| **LLM Abstraction Layer** | Gemini 기본 + OpenAI/Claude/Ollama 폴백. 벤더 락인 방지 |
| **REST API Layer** | 웹 대시보드와의 통신 전용. CLI는 직접 모듈 호출 |

### 4.4 Code Style & Rules

- Python: PEP 8 준수, Ruff를 통한 자동 포맷팅
- TypeScript: ESLint + Prettier 기반 일관된 코드 스타일
- 커밋 메시지: Conventional Commits 규약 준수
- 브랜치 전략: GitHub Flow (main + feature branches)
- 코드 리뷰: PR 기반 코드 리뷰 필수
- 용어 통일: 본 문서 전반에서 "크롤링 엔진"을 표준 용어로 사용 ("크롤러 엔진" 사용 금지)

---

## 5. Release Plan & Milestones

### Phase 1: Core Foundation (v0.1) — 예상 기간: 6주

> **목표:** CLI 기반 기본 진단 기능 구현 (LLM 없이 동작)

| 항목 | REQ | 내용 |
|------|-----|------|
| 정규식 기반 크롤링 엔진 | REQ-001 | 정규식 패턴 매칭으로 웹 페이지 구조 파싱, 엔드포인트 수집 |
| 패턴 기반 취약점 스캐닝 | REQ-010 | XSS, SQL Injection 등 주요 취약점 패턴 탐지 |
| 패턴 기반 자동 진단 실행 | REQ-004 (기본) | 크롤링 결과를 스캐너에 자동 전달, 기본 워크플로우 |
| CLI 인터페이스 | REQ-009 | `eazy scan`, `eazy crawl` 등 명령줄 기반 진단 실행 |
| 법적/윤리적 준수 (기본) | REQ-008 (기본) | 동의 확인 프롬프트, 감사 로그 기본 저장 |
| 기본 리포트 | - | 텍스트/JSON 형식 결과 출력 |

**산출물:** 실행 가능한 CLI 도구, 기본 취약점 탐지, 단위 테스트 커버리지 60%+

### Phase 2: AI Enhancement (v0.5) — 예상 기간: 10주

> **목표:** AI 기능 통합으로 진단 정확도 및 자동화 수준 향상

#### Phase 2a: 스마트 크롤링 (4주)

| 항목 | REQ | 내용 |
|------|-----|------|
| 스마트 크롤링 코어 | REQ-002A | Playwright 기반 헤드리스 브라우저 크롤링 |
| LLM Provider 추상화 및 인증 | REQ-002B | LLMProvider 인터페이스 + OAuth/API 키 다중 인증 + 멀티 계정 전환 |
| LLM 크롤링 강화 | REQ-002C | 숨겨진 엔드포인트 추론, 폼 채우기, 흐름도 생성 |
| LLM 호출 최적화 | REQ-002D | HTML 전처리, 선택적 호출, 패턴 캐싱, 배치 처리 |

#### Phase 2b: AI 공격 시나리오 (3주)

| 항목 | REQ | 내용 |
|------|-----|------|
| AI 공격 시나리오 생성 | REQ-003 | Gemini API 기반 자동 시나리오 생성 + 흐름도 기반 로직 취약점 도출 |
| AI 기반 진단 실행 | REQ-004 (AI) | AI 생성 시나리오 자동 실행, 동적 페이로드 조정 |

#### Phase 2c: 오탐 필터링 및 지식 관리 (3주)

| 항목 | REQ | 내용 |
|------|-----|------|
| 오탐 필터링 AI | REQ-005A | AI 기반 오탐/진양성 자동 분류, PoC 생성 |
| RAG 지식 관리 | REQ-005B | Qdrant 벡터 DB 통합, 취약점 지식 축적 |
| 인증/세션 관리 | REQ-007 | 다양한 인증 방식 지원, MFA, API Key |

**산출물:** AI 기반 자동 진단 엔진, RAG 지식 베이스, 오탐률 50% 이하, 테스트 커버리지 70%+

### Phase 3: Production Dashboard (v1.0) — 예상 기간: 8주

> **목표:** 프로덕션 수준의 웹 대시보드 및 완전한 기능 제공

| 항목 | REQ | 내용 |
|------|-----|------|
| 리포트 생성 | REQ-006 | PDF/HTML 형식 전문 리포트, CVSS 자동 산출 |
| 동시 다중 대상 진단 | REQ-011 | Celery 기반 병렬 작업 큐, 최대 10개 동시 진단 |
| 웹 대시보드 UI | - | React/Next.js 기반 로컬 웹 대시보드 |
| OWASP Top 10 완전 커버리지 | - | 10/10 카테고리 지원 |
| 법적/윤리적 준수 (완전) | REQ-008 (완전) | 포괄적 면책 조항, 상세 감사 로그, Rate limiting |

**산출물:** 프로덕션 레디 v1.0, 사용자 매뉴얼, 통합 테스트 커버리지 80%+, 성능 벤치마크 리포트

### Future: Extended Platform (v2.0+)

| 항목 | 내용 |
|------|------|
| API 전용 서버 진단 | UI 없는 REST/GraphQL API 진단 지원 |
| CI/CD 파이프라인 통합 | GitHub Actions, GitLab CI 등 연동 |
| Slack/Teams 알림 연동 | 진단 결과 알림 자동 발송 |
| Cloud SaaS 버전 | 클라우드 기반 서비스 제공 |

---

## 6. Open Questions

| # | 질문 | 우선순위 | 블로킹 Phase | 상태 | 비고 |
|---|------|----------|-------------|------|------|
| 1 | Gemini API 사용량 및 비용 최적화 전략은? | **P0** | Phase 2 | 미결 | Phase 2 시작 전 벤치마크 테스트 필수. 토큰 사용량 모니터링 필요 |
| 2 | 프로덕션 환경 진단 시 안전한 페이로드의 범위는? | **P0** | Phase 1 | 해결 | REQ-004 안전한 페이로드 가이드라인으로 정의 완료 |
| 3 | 오픈소스로 공개할 것인지, 상용 제품으로 개발할 것인지? | P1 | Phase 3 | 미결 | 라이선스 전략 결정 필요 |
| 4 | v1.0에서 API 전용 서버 진단을 부분적으로 포함할 것인지? | P2 | 해당 없음 | 미결 | 현재 v2.0으로 예정 |
| 5 | 진단 결과 데이터의 보관 기간 및 정책은? | P1 | Phase 1 | 해결 | NFR 3.3.4에서 최소 1년 보관으로 정의 |
| 6 | 멀티 테넌시 지원 범위는? (팀 기능) | P2 | 해당 없음 | 미결 | v1.0 범위 재검토 필요 |
| 7 | Gemini API 단일 의존 리스크 - Fallback LLM 전략은? (OpenAI GPT-4, Claude, Ollama 로컬 모델) | P1 | Phase 2 | 미결 | LLM Abstraction Layer 설계 시 Fallback 체인 정의 필요 |

**우선순위 정의:**
- **P0**: 즉시 해결 필요, 해당 Phase 시작 전 블로커
- **P1**: 해당 Phase 내에서 해결 필요, 설계/구현에 영향
- **P2**: 중요하지만 Phase 블로킹은 아님, 점진적 개선 가능

---

## Appendix

### A. Reference

- [XINT by Theori](https://xint.io/ko) - AI 기반 블랙박스 모의해킹 솔루션
- [OWASP Top 10 (2021)](https://owasp.org/www-project-top-ten/) — 집필 시점 기준 최신. 향후 업데이트 시 반영 필요
- [CVSS v3.1 Specification](https://www.first.org/cvss/specification-document)
- [OWASP Web Security Testing Guide](https://owasp.org/www-project-web-security-testing-guide/)

### B. Competitive Analysis

| 제품 | 유형 | 강점 | 약점 | EAZY 차별점 |
|------|------|------|------|-------------|
| **Burp Suite Pro** | 상용 | 업계 표준, 풍부한 확장 생태계 | 수동 작업 비중 높음, 높은 가격 | AI 자동화로 수동 작업 최소화 |
| **OWASP ZAP** | 오픈소스 | 무료, 활발한 커뮤니티 | 비즈니스 로직 취약점 미탐, 높은 오탐률 | LLM 기반 비즈니스 로직 분석, RAG 오탐 필터링 |
| **Nuclei** | 오픈소스 | 빠른 스캔 속도, 풍부한 템플릿 | 컨텍스트 이해 부족, 수동 템플릿 작성 필요 | AI 컨텍스트 이해로 동적 시나리오 생성 |
| **XINT (Theori)** | 상용 | AI 기반 고정밀 진단, 낮은 오탐률 | 비공개 솔루션, 매우 높은 가격 | 접근성 높은 가격/라이선스 모델 |
| **Acunetix** | 상용 | 포괄적 커버리지, 엔터프라이즈 기능 | 높은 비용, 무거운 리소스 사용 | 경량 로컬 실행, AI 오탐 필터링 |

**EAZY 핵심 차별점:**
1. **AI 네이티브 설계**: 크롤링부터 오탐 필터링까지 전 과정에 LLM 활용
2. **접근성**: 오픈소스/무료 모델, 투명한 비용 구조
3. **비즈니스 로직 취약점 탐지**: 기존 도구가 놓치는 맥락 기반 취약점 발견
4. **지속적 학습**: RAG 기반 지식 축적으로 사용할수록 정확도 향상

### C. Glossary

| 용어 | 설명 |
|------|------|
| 블랙박스 테스트 | 소스코드 없이 외부에서 애플리케이션을 테스트하는 방식 |
| OWASP Top 10 | 가장 심각한 웹 애플리케이션 보안 위험 10가지 목록 |
| PoC (Proof of Concept) | 취약점이 실제로 악용 가능함을 증명하는 코드 또는 절차 |
| CVSS | Common Vulnerability Scoring System, 취약점 심각도 점수 체계 |
| 오탐 (False Positive) | 실제로는 취약점이 아닌데 취약점으로 탐지된 결과 |
| 미탐 (False Negative) | 실제 취약점이 존재하는데 탐지하지 못한 경우 |
| SPA | Single Page Application, 단일 페이지 애플리케이션 |
| DevSecOps | 개발(Dev), 보안(Sec), 운영(Ops)을 통합하는 접근 방식 |
| RAG (Retrieval-Augmented Generation) | 외부 지식 베이스에서 관련 정보를 검색하여 AI 생성 결과를 보강하는 기술 |
| 지식 그래프 (Knowledge Graph) | 엔티티와 관계를 노드-엣지로 구조화한 데이터 모델 |
| 임베딩 (Embedding) | 텍스트/데이터를 고차원 벡터 공간의 수치 표현으로 변환한 것 |
| 벡터 DB (Vector Database) | 벡터 임베딩을 저장하고 유사도 검색을 수행하는 데이터베이스 |
| Cold Start | 초기 데이터 부재로 시스템 성능이 저하되는 문제 |
| Audit Log | 시스템 활동을 시간순으로 기록한 감사 추적 로그 |
